"""Python module to set up and manage multiple browser sessions in web application."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/application/01_session.ipynb.

# %% auto 0
__all__ = ['session_messages', 'session_tools', 'session_notis', 'default_tools', 'retrieve_session_message',
           'retrieve_session_tools', 'prepare_handler_schemas', 'execute_handler', 'retrieve_session_notis',
           'set_noti_sender', 'execute_send_notification', 'execute_stopper', 'prepare_sender_schema',
           'prepare_stopper_schema', 'start_notification_stream', 'prepare_notification_schemas',
           'execute_start_notification_stream', 'init_session', 'remove_session']

# %% ../../nbs/application/01_session.ipynb 4
import uuid

from typing import Callable, Optional
from ..core.fc import *
from ..core.fn_to_schema import *
from ..vision.ytlive import *
from ..vision.gpt4v import *
from ..vision.yolo import *
from ..vision.dtcam import *
from ..vision.plotting import *
from ..utils.store import *
from ..utils.file_manager import *
from ..utils.notification import *
from ..utils.bash_command import *

# %% ../../nbs/application/01_session.ipynb 6
session_messages = {}  # Mappping of session_id to messages

# %% ../../nbs/application/01_session.ipynb 7
def retrieve_session_message(session_id: str) -> list:
    """Retrieve the messages for a given session_id"""
    return session_messages.get(session_id, [])

# %% ../../nbs/application/01_session.ipynb 10
session_tools = {}  # Mappping of session_id to tools

# %% ../../nbs/application/01_session.ipynb 11
def retrieve_session_tools(session_id: str) -> list:
    """Retrieve the tools for a given session_id"""
    return session_tools.get(session_id, [])

# %% ../../nbs/application/01_session.ipynb 13
# Utility functions to manage tools per session
def prepare_handler_schemas(
    session_id: str,  # Session ID to use
    fixup: Callable = None,  # Optional function to fix up the execution
):
    return [
        handler_schema(function, service_name="toolbox_manager", fixup=fixup, session_id=session_id) for \
        function in [add_api_tools, add_function_tools, remove_tools]
    ]

def execute_handler(
    function_name: str,  # Name of the function to execute
    session_id: str,  # Session ID to use
    **kwargs,  # Additional arguments to pass to the function
):
    tools = session_tools[session_id]
    return execute_handler_core(tools, function_name, **kwargs)

# %% ../../nbs/application/01_session.ipynb 17
session_notis = {}  # Mappping of session_id to notification sender \
                    # and notification streams

# %% ../../nbs/application/01_session.ipynb 18
def retrieve_session_notis(session_id: str) -> tuple:
    """Retrieve the notification sender and streams for a given session_id"""
    return session_notis.get(session_id, None)

# %% ../../nbs/application/01_session.ipynb 19
def set_noti_sender(session_id: str, noti_sender: Callable):
    """Set the notification sender for a given session_id"""
    session_notis[session_id] = (noti_sender, {})

# %% ../../nbs/application/01_session.ipynb 20
# Utility functions to manage notifications per session
def execute_send_notification(function_name, session_id, msg, **kwargs):
    """Fixup function to send a notification."""
    global session_notis
    sender, _ = session_notis[session_id]  # Get the sender
    sender(msg)
    return 'Notification sent'

def execute_stopper(function_name, session_id, noti_id, **kwargs):
    """Fixup function to stop a notification stream."""
    global session_notis
    _, notis = session_notis[session_id]  # Get the notification streams 
    notis[noti_id].stop()  # Stop the stream with the given ID
    return 'Notification stream stopped'

# Utility to define the schemas for the sender and stopper
def prepare_sender_schema(session_id: str):
    return {
        'type': 'function',
        'function': {
            'name': 'send_notification',
            'description': 'Send a notification with a message',
            'metadata': {
                'session_id': session_id
            },
            'parameters': {'type': 'object',
                'properties': {'msg': {'type': 'string',
                'description': 'Notification message to send'}},
                'required': ['msg']},
            'fixup': f"{execute_send_notification.__module__}.{execute_send_notification.__name__}"
        }
    }

def prepare_stopper_schema(session_id: str):
    return {
        'type': 'function',
        'function': {
            'name': 'stop_notification',
            'description': 'Stop the notification stream',
            'parameters': {
                'type': 'object', 
                'properties': {
                    'noti_id': {
                        'type': 'string', 
                        'description': 'Unique UUID of the notification stream to stop, provided when the stream was started'}
                }, 
                'required': ['noti_id']},
            'metadata': {
                'session_id': session_id,
            },
            'fixup': f"{execute_stopper.__module__}.{execute_stopper.__name__}"
        }
    }

# %% ../../nbs/application/01_session.ipynb 24
def start_notification_stream(
    session_id: str,  # Session ID to use
    messages: list,  # All the previous messages in the conversation
):
    """Start a notification stream to monitor a process described in messages."""
    global session_notis
    global session_tools

    _, notis = session_notis[session_id]  # Get the notification streams

    # Define a new notification stream with a unique ID
    noti_id = str(uuid.uuid4())
    
    # Describe the sender and stopper functions
    sender_schema = prepare_sender_schema(session_id)
    stopper_schema = prepare_stopper_schema(session_id)

    # Define a function to start the stream
    def stream_starter(tools, messages):
        notis[noti_id] = StreamThread(noti_id, tools, messages)
        notis[noti_id].start()

    # Extract the tools for the session
    tools = session_tools[session_id]
    # Remove the stop_notification tool from the list of tools to avoid duplication
    tools = [ tool for tool in tools if tool['function']['name'] != 'stop_notification' ] 

    submessages = [ message for message in messages ]
    submessages.append(form_msg(
        'system',
        f'Notification stream started with ID {noti_id}. Complete the stream here.'
    ))

    # Start the notification stream
    notification_stream_core(
        tools, 
        submessages,
        stream_starter=stream_starter,
        send_notification_schema=sender_schema,
        stream_stopper_schema=stopper_schema
    )

    # Return the ID of the notification stream  
    return f"Notification stream started with ID {noti_id}" 

# %% ../../nbs/application/01_session.ipynb 26
def prepare_notification_schemas(
        session_id: str,  # Session ID to use
        fixup: Callable = None,  # Optional function to fix up the execution
    ):  # Prepare the notification schema
    schema = process_notification_schema(start_notification_stream)  # Get the schema for starting notification stream
    # Set additional metadata
    schema['function']['metadata']['session_id'] = session_id  
    if fixup: schema['function']['fixup'] = f"{fixup.__module__}.{fixup.__name__}"
    return schema

def execute_start_notification_stream(function_name, session_id, messages, **kwargs):
    """Fixup function to start a notification stream."""
    return start_notification_stream(session_id, messages)

# %% ../../nbs/application/01_session.ipynb 28
# Set up default tools from our `llmcam.utils` and `llmcam.vision` modules.
default_tools = [function_schema(fn) for fn in (
    select_youtube_live_url,
    capture_youtube_live_frame, 
    ask_gpt4v_about_image_file,
    detect_objects,
    cap,
    list_image_files,
    list_detection_files,
    plot_object,
    execute_bash_command,
    camera_address_book,
)]

# %% ../../nbs/application/01_session.ipynb 29
def init_session(session_id: Optional[str] = None):
    if session_id is None or session_id not in session_messages:
        # Initialize tools in session tools and create a session ID
        session_id = str(uuid.uuid4())

        # Add default tools, prepare handler schemas, prepare notification schemas, and prepare stopper schema
        session_tools[session_id] = []
        session_tools[session_id].extend(prepare_handler_schemas(session_id, execute_handler))
        session_tools[session_id].extend(default_tools)
        session_tools[session_id].append(prepare_notification_schemas(session_id, execute_start_notification_stream))
        session_tools[session_id].append(prepare_stopper_schema(session_id))

        # Initialize messages in session messages
        session_messages[session_id] = []
    
    return session_id

# %% ../../nbs/application/01_session.ipynb 30
def remove_session(session_id: str):
    """Remove the session with the given session_id"""
    if session_id in session_messages:
        del session_messages[session_id]
    if session_id in session_tools:
        del session_tools[session_id]
    if session_id in session_notis:
        _, notis = session_notis[session_id]
        for noti in notis.values():
            noti.stop()
        del session_notis[session_id]
